{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Crear una aplicaci\u00f3n FullStack con MySQL, SpringBoot y ReactJS Introducci\u00f3n Base de datos Backend FrontEnd (Soon)","title":"Inicio"},{"location":"#crear-una-aplicacion-fullstack-con-mysql-springboot-y-reactjs","text":"","title":"Crear una aplicaci\u00f3n FullStack con MySQL, SpringBoot y ReactJS"},{"location":"#introduccion","text":"","title":"Introducci\u00f3n"},{"location":"#base-de-datos","text":"","title":"Base de datos"},{"location":"#backend","text":"","title":"Backend"},{"location":"#frontend-soon","text":"","title":"FrontEnd (Soon)"},{"location":"backendp1/","text":"Backend con Spring Boot El desarrollo web backend se refiere a la creaci\u00f3n y gesti\u00f3n de la parte del servidor de una aplicaci\u00f3n web. Es la columna vertebral que sostiene las operaciones y funcionalidades que el usuario no ve directamente, pero que son cruciales para el funcionamiento del sitio web. Esta parte del desarrollo se centra en la base de datos, la l\u00f3gica del servidor, la autenticaci\u00f3n del usuario, la manipulaci\u00f3n de datos y la comunicaci\u00f3n entre el servidor y el cliente. Fundamentos del Desarrollo Web Backend El backend est\u00e1 compuesto por varios elementos clave: Servidor Web : Maneja las solicitudes del cliente y las respuestas del servidor. Base de Datos : Almacena y gestiona los datos que utiliza la aplicaci\u00f3n. APIs : Conectan diferentes partes de la aplicaci\u00f3n y permiten la comunicaci\u00f3n entre diferentes servicios. Lenguajes de Programaci\u00f3n : Como Java, Python, Ruby, y Node.js, que se utilizan para escribir la l\u00f3gica del servidor. El backend es responsable de asegurar que la aplicaci\u00f3n web sea segura, eficiente y escalable. La elecci\u00f3n de herramientas y tecnolog\u00edas adecuadas es esencial para el desarrollo exitoso de aplicaciones robustas y de alto rendimiento. Ventajas de Usar Spring Boot Spring Boot es un marco de desarrollo para aplicaciones backend basado en Java que ha ganado popularidad por su simplicidad y capacidad para acelerar el desarrollo de aplicaciones empresariales. Aqu\u00ed algunas de sus ventajas: Configuraci\u00f3n Simplificada : Spring Boot elimina la necesidad de configuraciones complejas. Utiliza convenciones sobre configuraciones, lo que permite a los desarrolladores centrarse m\u00e1s en la l\u00f3gica de negocio que en las configuraciones. Desarrollo R\u00e1pido : Con su enfoque basado en principios de opini\u00f3n, permite un arranque r\u00e1pido de aplicaciones. Su generador de proyectos inicializa r\u00e1pidamente los proyectos con las dependencias adecuadas. Integraci\u00f3n con El ecosistema Spring : Spring Boot es parte del ecosistema de Spring, que ofrece una amplia gama de herramientas y bibliotecas, como Spring Security para la gesti\u00f3n de seguridad y Spring Data para la interacci\u00f3n con bases de datos. Microservicios : Es ideal para el desarrollo de aplicaciones basadas en microservicios, debido a su capacidad para crear servicios independientes y desplegables que pueden comunicarse entre s\u00ed. Amplia Comunidad y Soporte : Cuenta con una comunidad activa y una gran cantidad de recursos y documentaci\u00f3n, lo que facilita la resoluci\u00f3n de problemas y la b\u00fasqueda de soluciones. Monitoreo y Gesti\u00f3n : Spring Boot Actuator proporciona herramientas para monitorear y gestionar aplicaciones en producci\u00f3n, facilitando el mantenimiento y la detecci\u00f3n de problemas. En resumen, el desarrollo backend es fundamental para la funcionalidad y el rendimiento de una aplicaci\u00f3n web, y elegir el marco adecuado puede marcar una gran diferencia. Spring Boot ofrece una serie de ventajas que lo hacen una excelente opci\u00f3n para desarrolladores que buscan rapidez, simplicidad y robustez en sus proyectos. Crear un proyecto con Spring Boot Para crear un proyecto con Spring Boot, basta con utilizar la herramienta basada en la web: Spring Initializr : Esta herramienta es bastante intuitiva y genera un arquetipo de una aplicaci\u00f3n de Spring Boot con todo lo que necesitemos para nuestro sistema. Estructura de un proyecto en Spring Boot Una estructura com\u00fan de un proyecto en Spring Boot es la siguiente: my-spring-boot-project/ \u2502 \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 main/ \u2502 \u2502 \u251c\u2500\u2500 java/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 com/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 mycompany/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 myproject/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 MySpringBootApplication.java \u2502 \u2502 \u2502 \u251c\u2500\u2500 controller/ \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 MyController.java \u2502 \u2502 \u2502 \u251c\u2500\u2500 service/ \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 MyService.java \u2502 \u2502 \u2502 \u251c\u2500\u2500 repository/ \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 MyRepository.java \u2502 \u2502 \u2502 \u2514\u2500\u2500 model/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 MyModel.java \u2502 \u2502 \u251c\u2500\u2500 resources/ \u2502 \u2502 \u251c\u2500\u2500 application.properties \u2502 \u2502 \u251c\u2500\u2500 static/ \u2502 \u2502 \u251c\u2500\u2500 templates/ \u2502 \u2502 \u2514\u2500\u2500 META-INF/ \u2502 \u2514\u2500\u2500 test/ \u2502 \u2514\u2500\u2500 java/ \u2502 \u2514\u2500\u2500 com/ \u2502 \u2514\u2500\u2500 mycompany/ \u2502 \u2514\u2500\u2500 myproject/ \u2502 \u2514\u2500\u2500 MySpringBootApplicationTests.java \u2502 \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 mvnw \u251c\u2500\u2500 mvnw.cmd \u251c\u2500\u2500 pom.xml \u2514\u2500\u2500 README.md #### Descripci\u00f3n de la Estructura _src/main/java_: Contiene el c\u00f3digo fuente principal del proyecto. _com/mycompany/myproject_: Paquete base del proyecto. _MySpringBootApplication.java_: La clase principal que inicia la aplicaci\u00f3n Spring Boot. _controller_: Paquete que contiene las clases de controladores, encargados de manejar las solicitudes HTTP. _service_: Paquete para las clases de servicio, donde se implementa la l\u00f3gica de negocio. _repository_: Paquete para las interfaces de repositorio, encargadas de la interacci\u00f3n con la base de datos. _model_: Paquete para las clases de modelo de datos. _src/main/resources_: Contiene los recursos de la aplicaci\u00f3n. _application.properties_: Archivo de configuraci\u00f3n para la aplicaci\u00f3n. _static_: Directorio para archivos est\u00e1ticos (CSS, JavaScript, im\u00e1genes). _templates_: Directorio para plantillas de vista (por ejemplo, archivos Thymeleaf). _META-INF_: Contiene el archivo MANIFEST.MF y otros recursos de configuraci\u00f3n. _src/test/java_: Contiene las pruebas unitarias del proyecto. _MySpringBootApplicationTests.java_: Clase para las pruebas de la aplicaci\u00f3n. _pom.xml_: Archivo de configuraci\u00f3n de Maven, donde se declaran las dependencias y plugins del proyecto. _README.md_: Archivo de documentaci\u00f3n del proyecto. Esta estructura proporciona una organizaci\u00f3n clara y modular, que facilita el mantenimiento y la escalabilidad del proyecto.","title":"Backend API - Parte1"},{"location":"backendp1/#backend-con-spring-boot","text":"El desarrollo web backend se refiere a la creaci\u00f3n y gesti\u00f3n de la parte del servidor de una aplicaci\u00f3n web. Es la columna vertebral que sostiene las operaciones y funcionalidades que el usuario no ve directamente, pero que son cruciales para el funcionamiento del sitio web. Esta parte del desarrollo se centra en la base de datos, la l\u00f3gica del servidor, la autenticaci\u00f3n del usuario, la manipulaci\u00f3n de datos y la comunicaci\u00f3n entre el servidor y el cliente.","title":"Backend con Spring Boot"},{"location":"backendp1/#fundamentos-del-desarrollo-web-backend","text":"El backend est\u00e1 compuesto por varios elementos clave: Servidor Web : Maneja las solicitudes del cliente y las respuestas del servidor. Base de Datos : Almacena y gestiona los datos que utiliza la aplicaci\u00f3n. APIs : Conectan diferentes partes de la aplicaci\u00f3n y permiten la comunicaci\u00f3n entre diferentes servicios. Lenguajes de Programaci\u00f3n : Como Java, Python, Ruby, y Node.js, que se utilizan para escribir la l\u00f3gica del servidor. El backend es responsable de asegurar que la aplicaci\u00f3n web sea segura, eficiente y escalable. La elecci\u00f3n de herramientas y tecnolog\u00edas adecuadas es esencial para el desarrollo exitoso de aplicaciones robustas y de alto rendimiento.","title":"Fundamentos del Desarrollo Web Backend"},{"location":"backendp1/#ventajas-de-usar-spring-boot","text":"Spring Boot es un marco de desarrollo para aplicaciones backend basado en Java que ha ganado popularidad por su simplicidad y capacidad para acelerar el desarrollo de aplicaciones empresariales. Aqu\u00ed algunas de sus ventajas: Configuraci\u00f3n Simplificada : Spring Boot elimina la necesidad de configuraciones complejas. Utiliza convenciones sobre configuraciones, lo que permite a los desarrolladores centrarse m\u00e1s en la l\u00f3gica de negocio que en las configuraciones. Desarrollo R\u00e1pido : Con su enfoque basado en principios de opini\u00f3n, permite un arranque r\u00e1pido de aplicaciones. Su generador de proyectos inicializa r\u00e1pidamente los proyectos con las dependencias adecuadas. Integraci\u00f3n con El ecosistema Spring : Spring Boot es parte del ecosistema de Spring, que ofrece una amplia gama de herramientas y bibliotecas, como Spring Security para la gesti\u00f3n de seguridad y Spring Data para la interacci\u00f3n con bases de datos. Microservicios : Es ideal para el desarrollo de aplicaciones basadas en microservicios, debido a su capacidad para crear servicios independientes y desplegables que pueden comunicarse entre s\u00ed. Amplia Comunidad y Soporte : Cuenta con una comunidad activa y una gran cantidad de recursos y documentaci\u00f3n, lo que facilita la resoluci\u00f3n de problemas y la b\u00fasqueda de soluciones. Monitoreo y Gesti\u00f3n : Spring Boot Actuator proporciona herramientas para monitorear y gestionar aplicaciones en producci\u00f3n, facilitando el mantenimiento y la detecci\u00f3n de problemas. En resumen, el desarrollo backend es fundamental para la funcionalidad y el rendimiento de una aplicaci\u00f3n web, y elegir el marco adecuado puede marcar una gran diferencia. Spring Boot ofrece una serie de ventajas que lo hacen una excelente opci\u00f3n para desarrolladores que buscan rapidez, simplicidad y robustez en sus proyectos.","title":"Ventajas de Usar Spring Boot"},{"location":"backendp1/#crear-un-proyecto-con-spring-boot","text":"Para crear un proyecto con Spring Boot, basta con utilizar la herramienta basada en la web: Spring Initializr : Esta herramienta es bastante intuitiva y genera un arquetipo de una aplicaci\u00f3n de Spring Boot con todo lo que necesitemos para nuestro sistema.","title":"Crear un proyecto con Spring Boot"},{"location":"backendp1/#estructura-de-un-proyecto-en-spring-boot","text":"Una estructura com\u00fan de un proyecto en Spring Boot es la siguiente: my-spring-boot-project/ \u2502 \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 main/ \u2502 \u2502 \u251c\u2500\u2500 java/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 com/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 mycompany/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 myproject/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 MySpringBootApplication.java \u2502 \u2502 \u2502 \u251c\u2500\u2500 controller/ \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 MyController.java \u2502 \u2502 \u2502 \u251c\u2500\u2500 service/ \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 MyService.java \u2502 \u2502 \u2502 \u251c\u2500\u2500 repository/ \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 MyRepository.java \u2502 \u2502 \u2502 \u2514\u2500\u2500 model/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 MyModel.java \u2502 \u2502 \u251c\u2500\u2500 resources/ \u2502 \u2502 \u251c\u2500\u2500 application.properties \u2502 \u2502 \u251c\u2500\u2500 static/ \u2502 \u2502 \u251c\u2500\u2500 templates/ \u2502 \u2502 \u2514\u2500\u2500 META-INF/ \u2502 \u2514\u2500\u2500 test/ \u2502 \u2514\u2500\u2500 java/ \u2502 \u2514\u2500\u2500 com/ \u2502 \u2514\u2500\u2500 mycompany/ \u2502 \u2514\u2500\u2500 myproject/ \u2502 \u2514\u2500\u2500 MySpringBootApplicationTests.java \u2502 \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 mvnw \u251c\u2500\u2500 mvnw.cmd \u251c\u2500\u2500 pom.xml \u2514\u2500\u2500 README.md #### Descripci\u00f3n de la Estructura _src/main/java_: Contiene el c\u00f3digo fuente principal del proyecto. _com/mycompany/myproject_: Paquete base del proyecto. _MySpringBootApplication.java_: La clase principal que inicia la aplicaci\u00f3n Spring Boot. _controller_: Paquete que contiene las clases de controladores, encargados de manejar las solicitudes HTTP. _service_: Paquete para las clases de servicio, donde se implementa la l\u00f3gica de negocio. _repository_: Paquete para las interfaces de repositorio, encargadas de la interacci\u00f3n con la base de datos. _model_: Paquete para las clases de modelo de datos. _src/main/resources_: Contiene los recursos de la aplicaci\u00f3n. _application.properties_: Archivo de configuraci\u00f3n para la aplicaci\u00f3n. _static_: Directorio para archivos est\u00e1ticos (CSS, JavaScript, im\u00e1genes). _templates_: Directorio para plantillas de vista (por ejemplo, archivos Thymeleaf). _META-INF_: Contiene el archivo MANIFEST.MF y otros recursos de configuraci\u00f3n. _src/test/java_: Contiene las pruebas unitarias del proyecto. _MySpringBootApplicationTests.java_: Clase para las pruebas de la aplicaci\u00f3n. _pom.xml_: Archivo de configuraci\u00f3n de Maven, donde se declaran las dependencias y plugins del proyecto. _README.md_: Archivo de documentaci\u00f3n del proyecto. Esta estructura proporciona una organizaci\u00f3n clara y modular, que facilita el mantenimiento y la escalabilidad del proyecto.","title":"Estructura de un proyecto en Spring Boot"},{"location":"backendp2/","text":"Crear el Proyecto Spring Boot con Visual Studio Code Hay Alternativas a VSCode que pueden ser m\u00e1s c\u00f3modas de trabajar con Spring Boot (IntelliJ, Spring Tool Suite, entre otros). Sin embargo, vamos a trabajar con VSCode debido a la familiaridad que algunos de ustedes tienen con la herramienta. En VSCode recomiendo instalar las siguientes extensiones: Extension Pack for Java Language Support for Java(TM) by Red Hat Spring Boot Extension Pack spring Boot Gradle Plus (Para instalar dependencias al proyecto con Gradle) Pasos para crear el proyecto en VSCode En \u00edcono del explorador, dar clic en el bot\u00f3n Create Java Project Select project type : Luego, sale una desde el buscador, el tipo de proyecto. En este punto se selecciona Spring Boot. Select (Spring boot) Project Type : Se escoge el tipo de proyecto Spring Boot. Ac\u00e1 seleccionaremos Gradle Project Specify Spring boot project version : Luego, escogemos la versi\u00f3n del proyecto. Utilizaremos la que est\u00e9 selecciona por defecto. Select proyect language : En este punto se escoge el lenguaje. Seleccionamos Java Input group id : Luego, seleccionamos el Identificador del grupo ( Group id ) del proyecto. Para nuestro proyecto, escribiremos \"com.ejemplo\" Input artefact id : Ahora, escribiremos el Identificador del artectacto ( Artefact Id ), es decir nuestra aplicaci\u00f3n. Ac\u00e1 escribimos: rentacar Specify packaging type : Luego, seleccionamos el tipo de empaquetamiento del proyecto. Selecionaremos Jar Specify Java version : En este punto seleccionamos la versi\u00f3n de Java. Lo correcto es escoger la que tenemos instalada en nuestro equipo. Es necesario tener instalada una versi\u00f3n de java igual o superior a la 17 Si nuestra versi\u00f3n no coincide con la que nos muestra el asistente, la cambiamos luego en el archivo build.gradle : gradle java { toolchain { languageVersion = JavaLanguageVersion.of(23) } } Choose dependencies Ac\u00e1 selecionamos las dependencias que utilizaremos en el proyecto. en el cuadro Search dependencies las buscamos y presionamos Espacio para seleccionarla. Finalmente, presionamos Enter para continuar. Si no hay errores, se nos presenta una ventana que indica que se cre\u00f3 exitosamente el proyecto y que si deseamos abrir la carpeta del proyecto. Ac\u00e1 damos clic en el bot\u00f3n Open Organizar el proyecto Vamos a tratar de organizar el proyecto con la configuraci\u00f3n recomendada. Para eso, le damos clic derecho en el nombre del \u00faltimo paquete dentro de la ruta src/main/java/com/example/rentacar y le damos clic a la opci\u00f3n New Java Package le damos un nombre al paquete y luego presionamos Enter para que lo cree. Los paquetes a crear inicialmente son entity, controller, service, repository Se puede (y se debe) separar m\u00e1s las responsabilidades dentro del proyecto, agregando paquetes como dtos, model, etc. Por el momento lo dejaremos con los paquetes iniciales. Creando las entidades JPA Con base en los objetos de base de datos mostrados en el cap\u00edtulo anterior, vamos a generar las Entidades de JPA y los repositorios para poder gestionar estas entidades. Damos clic derecho en la carpeta de entidades ( entity ), luego clic en New Java File y luego clic en Class Le damos el nombre de la clase y presionamos Enter , por ejemplo, la entidad Cliente. Este es el c\u00f3digo de la clase Cliente basado en nuestra base de datos: package com.example.rentacar.entity; import java.util.List; import jakarta.persistence.Entity; import jakarta.persistence.GeneratedValue; import jakarta.persistence.GenerationType; import jakarta.persistence.Id; import jakarta.persistence.OneToMany; import lombok.Data; @Entity @Data public class Cliente { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer idCliente; private String nombre; private String direccion; private String telefono; private String email; @OneToMany(mappedBy = \"idReserva\") private List<Reserva> reservas; } En JPA, las clases son anotadas para que puedan representar los elementos de la base de datos. Por ejemplo, la anotaci\u00f3n @Entity determina que una clase va a representar una tabla en la base de datos. la anotaci\u00f3n @Id representa en en el atributo de la clase, la columna identidad de la tabla. Otras anotaciones \u00fatiles pueden ser consultadas en el siguiente enlace: Manual avanzado de JPA El resto de entidades se puede ver en el repositorio de ejemplo de esta guia. Creando los repositorios Los repositorios JPA nos permiten manejar los datos de las entidades. Hay varios tipos de entidades en JPA que tienen definidos m\u00e9todos que podemos utilizar para buscar, guardar, actualizar y eliminar datos de las entidades. Una de esas interfaces es CrudRepository, que vamos a utilizar para manejar las entidades que creamos anteriormente. Lo Ejemplo de repositorio de Cliente: package com.example.rentacar.repository; import org.springframework.data.repository.CrudRepository; import com.example.rentacar.entity.Cliente; public interface ClienteRepositorio extends CrudRepository<Cliente, Integer> { } Al extender la interfaz CrudRepository se tienen disponibles m\u00e9todos como los siguientes: save: guarda una entidad saveAll: guarda las entidades de una lista iterable findById: busca por el identificador existsById: verifica si existe un identificador findAll: devuelve todos los elementos para la entidad findAllById: busca todos los elementos que tengan el identificador count: devuelve el total de registros de la entidad deleteById: elimina un registro para el identificador delete: elimina la entidad deleteAllById: elimina todos los elementos que correspondan con el id deleteAll(Iterable): elimina todos los elementos que se reciban en el par\u00e1metro deleteAll(): elimina todos los elementos M\u00e1s informaci\u00f3n sobre los repositorios de JPA se puede encontrar en el siguiente enlace: JPA Repositories Creando los servicios Los servicios los utilizamos para separar las responsabilidades por unidades dentro de la aplicaci\u00f3n. La idea es que los servicios sean los que implementen a los repositorios y los datos, y que los controladores llamen \u00fanicamente a los servicios. Tambi\u00e9n es buena pr\u00e1ctica agregar un objeto DTO basado en las entidades para que sea utilizado por los controladores y no usen directamente \u00e9stas. En este proyecto por aspectos de simplicidad, de momento vamos a ignorar esta pr\u00e1ctica. La pr\u00e1ctica que si realizarmos en este gu\u00eda es hacer una abstracci\u00f3n de los servicios, es decir, realizaremos interfaces para acceder a los servicios. Esto tiene algunas ventajas como modularizaci\u00f3n, seguridad, entre otros. Un ejemplo de servicio para cliente ser\u00eda realizar la interfaz IClienteServicio que tendr\u00e1 las definiciones de los servicios y habr\u00e1 una clase que implementar\u00e1 la interfaz: package com.example.rentacar.service; import java.util.List; import com.example.rentacar.entity.Cliente; public interface IClienteServicio { Cliente crearCliente(Cliente datosCliente) throws Exception; Cliente obtenerClientePorId(Integer id) throws Exception; List<Cliente> obtenerClientes() throws Exception; } Tambi\u00e9n se tiene el c\u00f3digo de la clase que implementa la interfaz: package com.example.rentacar.service.impl; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import com.example.rentacar.entity.Cliente; import com.example.rentacar.repository.ClienteRepositorio; import com.example.rentacar.service.IClienteServicio; @Service public class ClienteServicioImpl implements IClienteServicio { @Autowired private ClienteRepositorio repo; @Override public Cliente crearCliente(Cliente datosCliente) throws Exception { return repo.save(datosCliente); } @Override public Cliente obtenerClientePorId(Integer id) throws Exception { return repo.findById(id).orElseThrow(() -> new Exception(\"Cliente no encontrado\")); } @Override public Iterable<Cliente> obtenerClientes() throws Exception { return repo.findAll(); } }","title":"Backend API - Parte2"},{"location":"backendp2/#crear-el-proyecto-spring-boot-con-visual-studio-code","text":"Hay Alternativas a VSCode que pueden ser m\u00e1s c\u00f3modas de trabajar con Spring Boot (IntelliJ, Spring Tool Suite, entre otros). Sin embargo, vamos a trabajar con VSCode debido a la familiaridad que algunos de ustedes tienen con la herramienta. En VSCode recomiendo instalar las siguientes extensiones: Extension Pack for Java Language Support for Java(TM) by Red Hat Spring Boot Extension Pack spring Boot Gradle Plus (Para instalar dependencias al proyecto con Gradle)","title":"Crear el Proyecto Spring Boot con Visual Studio Code"},{"location":"backendp2/#pasos-para-crear-el-proyecto-en-vscode","text":"En \u00edcono del explorador, dar clic en el bot\u00f3n Create Java Project Select project type : Luego, sale una desde el buscador, el tipo de proyecto. En este punto se selecciona Spring Boot. Select (Spring boot) Project Type : Se escoge el tipo de proyecto Spring Boot. Ac\u00e1 seleccionaremos Gradle Project Specify Spring boot project version : Luego, escogemos la versi\u00f3n del proyecto. Utilizaremos la que est\u00e9 selecciona por defecto. Select proyect language : En este punto se escoge el lenguaje. Seleccionamos Java Input group id : Luego, seleccionamos el Identificador del grupo ( Group id ) del proyecto. Para nuestro proyecto, escribiremos \"com.ejemplo\" Input artefact id : Ahora, escribiremos el Identificador del artectacto ( Artefact Id ), es decir nuestra aplicaci\u00f3n. Ac\u00e1 escribimos: rentacar Specify packaging type : Luego, seleccionamos el tipo de empaquetamiento del proyecto. Selecionaremos Jar Specify Java version : En este punto seleccionamos la versi\u00f3n de Java. Lo correcto es escoger la que tenemos instalada en nuestro equipo. Es necesario tener instalada una versi\u00f3n de java igual o superior a la 17 Si nuestra versi\u00f3n no coincide con la que nos muestra el asistente, la cambiamos luego en el archivo build.gradle : gradle java { toolchain { languageVersion = JavaLanguageVersion.of(23) } } Choose dependencies Ac\u00e1 selecionamos las dependencias que utilizaremos en el proyecto. en el cuadro Search dependencies las buscamos y presionamos Espacio para seleccionarla. Finalmente, presionamos Enter para continuar. Si no hay errores, se nos presenta una ventana que indica que se cre\u00f3 exitosamente el proyecto y que si deseamos abrir la carpeta del proyecto. Ac\u00e1 damos clic en el bot\u00f3n Open","title":"Pasos para crear el proyecto en VSCode"},{"location":"backendp2/#organizar-el-proyecto","text":"Vamos a tratar de organizar el proyecto con la configuraci\u00f3n recomendada. Para eso, le damos clic derecho en el nombre del \u00faltimo paquete dentro de la ruta src/main/java/com/example/rentacar y le damos clic a la opci\u00f3n New Java Package le damos un nombre al paquete y luego presionamos Enter para que lo cree. Los paquetes a crear inicialmente son entity, controller, service, repository Se puede (y se debe) separar m\u00e1s las responsabilidades dentro del proyecto, agregando paquetes como dtos, model, etc. Por el momento lo dejaremos con los paquetes iniciales.","title":"Organizar el proyecto"},{"location":"backendp2/#creando-las-entidades-jpa","text":"Con base en los objetos de base de datos mostrados en el cap\u00edtulo anterior, vamos a generar las Entidades de JPA y los repositorios para poder gestionar estas entidades. Damos clic derecho en la carpeta de entidades ( entity ), luego clic en New Java File y luego clic en Class Le damos el nombre de la clase y presionamos Enter , por ejemplo, la entidad Cliente. Este es el c\u00f3digo de la clase Cliente basado en nuestra base de datos: package com.example.rentacar.entity; import java.util.List; import jakarta.persistence.Entity; import jakarta.persistence.GeneratedValue; import jakarta.persistence.GenerationType; import jakarta.persistence.Id; import jakarta.persistence.OneToMany; import lombok.Data; @Entity @Data public class Cliente { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer idCliente; private String nombre; private String direccion; private String telefono; private String email; @OneToMany(mappedBy = \"idReserva\") private List<Reserva> reservas; } En JPA, las clases son anotadas para que puedan representar los elementos de la base de datos. Por ejemplo, la anotaci\u00f3n @Entity determina que una clase va a representar una tabla en la base de datos. la anotaci\u00f3n @Id representa en en el atributo de la clase, la columna identidad de la tabla. Otras anotaciones \u00fatiles pueden ser consultadas en el siguiente enlace: Manual avanzado de JPA El resto de entidades se puede ver en el repositorio de ejemplo de esta guia.","title":"Creando las entidades JPA"},{"location":"backendp2/#creando-los-repositorios","text":"Los repositorios JPA nos permiten manejar los datos de las entidades. Hay varios tipos de entidades en JPA que tienen definidos m\u00e9todos que podemos utilizar para buscar, guardar, actualizar y eliminar datos de las entidades. Una de esas interfaces es CrudRepository, que vamos a utilizar para manejar las entidades que creamos anteriormente. Lo Ejemplo de repositorio de Cliente: package com.example.rentacar.repository; import org.springframework.data.repository.CrudRepository; import com.example.rentacar.entity.Cliente; public interface ClienteRepositorio extends CrudRepository<Cliente, Integer> { } Al extender la interfaz CrudRepository se tienen disponibles m\u00e9todos como los siguientes: save: guarda una entidad saveAll: guarda las entidades de una lista iterable findById: busca por el identificador existsById: verifica si existe un identificador findAll: devuelve todos los elementos para la entidad findAllById: busca todos los elementos que tengan el identificador count: devuelve el total de registros de la entidad deleteById: elimina un registro para el identificador delete: elimina la entidad deleteAllById: elimina todos los elementos que correspondan con el id deleteAll(Iterable): elimina todos los elementos que se reciban en el par\u00e1metro deleteAll(): elimina todos los elementos M\u00e1s informaci\u00f3n sobre los repositorios de JPA se puede encontrar en el siguiente enlace: JPA Repositories","title":"Creando los repositorios"},{"location":"backendp2/#creando-los-servicios","text":"Los servicios los utilizamos para separar las responsabilidades por unidades dentro de la aplicaci\u00f3n. La idea es que los servicios sean los que implementen a los repositorios y los datos, y que los controladores llamen \u00fanicamente a los servicios. Tambi\u00e9n es buena pr\u00e1ctica agregar un objeto DTO basado en las entidades para que sea utilizado por los controladores y no usen directamente \u00e9stas. En este proyecto por aspectos de simplicidad, de momento vamos a ignorar esta pr\u00e1ctica. La pr\u00e1ctica que si realizarmos en este gu\u00eda es hacer una abstracci\u00f3n de los servicios, es decir, realizaremos interfaces para acceder a los servicios. Esto tiene algunas ventajas como modularizaci\u00f3n, seguridad, entre otros. Un ejemplo de servicio para cliente ser\u00eda realizar la interfaz IClienteServicio que tendr\u00e1 las definiciones de los servicios y habr\u00e1 una clase que implementar\u00e1 la interfaz: package com.example.rentacar.service; import java.util.List; import com.example.rentacar.entity.Cliente; public interface IClienteServicio { Cliente crearCliente(Cliente datosCliente) throws Exception; Cliente obtenerClientePorId(Integer id) throws Exception; List<Cliente> obtenerClientes() throws Exception; } Tambi\u00e9n se tiene el c\u00f3digo de la clase que implementa la interfaz: package com.example.rentacar.service.impl; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import com.example.rentacar.entity.Cliente; import com.example.rentacar.repository.ClienteRepositorio; import com.example.rentacar.service.IClienteServicio; @Service public class ClienteServicioImpl implements IClienteServicio { @Autowired private ClienteRepositorio repo; @Override public Cliente crearCliente(Cliente datosCliente) throws Exception { return repo.save(datosCliente); } @Override public Cliente obtenerClientePorId(Integer id) throws Exception { return repo.findById(id).orElseThrow(() -> new Exception(\"Cliente no encontrado\")); } @Override public Iterable<Cliente> obtenerClientes() throws Exception { return repo.findAll(); } }","title":"Creando los servicios"},{"location":"backendp3/","text":"Desarrollo del Backend API (I) Creando los controladores En esta parte creamos los controladores que utilizaran los servicios. Los controladores son etiquetados con @RestController, que indica que la clase manejar\u00e1 peticiones de tipo REST. Este es un ejemplo del controlador de cliente: package com.example.rentacar.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import com.example.rentacar.entity.Cliente; import com.example.rentacar.service.IClienteServicio; import java.util.Optional; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.PutMapping; @RestController @RequestMapping(\"/api/clientes\") public class ClienteControlador { @Autowired private IClienteServicio clienteServicio; @GetMapping(\"/{id}\") public ResponseEntity<Cliente> getClientePorId(@PathVariable Integer id) { Optional<Cliente> opCliente = clienteServicio.obtenerClientePorId(id); if (opCliente.isPresent()) { return ResponseEntity.ok().body(opCliente.get()); } return ResponseEntity.notFound().build(); } @PostMapping public ResponseEntity<Cliente> crearCliente(@RequestBody Cliente entity) { Cliente nuevoCliente = clienteServicio.crearCliente(entity); return ResponseEntity.status(HttpStatus.CREATED).body(nuevoCliente); } @PutMapping(\"/{id}\") public ResponseEntity<Cliente> actualizarCliente(@PathVariable Integer id, @RequestBody Cliente clienteOld) { Optional<Cliente> cliente = clienteServicio.obtenerClientePorId(id); if (cliente.isPresent()) { Cliente clienteNew = cliente.get(); clienteNew.setDireccion(clienteOld.getDireccion()); clienteNew.setEmail(clienteOld.getEmail()); clienteNew.setNombre(clienteOld.getNombre()); clienteNew.setTelefono(clienteOld.getTelefono()); return ResponseEntity.ok(clienteServicio.crearCliente(clienteNew)); } return ResponseEntity.notFound().build(); } } Configurar la conexi\u00f3n a la base de datos Para conectarnos a la base de datos desde el backend, agregamos los siguientes datos al archivo de configuraci\u00f3n de la aplicaci\u00f3n, application.properties : #URL de conexi\u00f3n a la base de datos spring.datasource.url=jdbc:mysql://localhost:3307/rentacardb #Tipo de controlador de la BD spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect #Muestra en consola las consultas sql generadas spring.jpa.show-sql=true spring.datasource.username=root spring.datasource.password=root Ejecutando la aplicaci\u00f3n Para ejecutar la aplicaci\u00f3n tenemos varias opciones, la primera es ejecutar el wrapper de gradle , en la terminal, con el siguiente comando: gradlew.bat bootRun La otra opci\u00f3n es usar la extension Spring Boot Dashboard desde el \u00edcono Run de la aplicaci\u00f3n, como se ve en la imagen: Probando el Backend con Postman Postman , es una popular herramienta para desarrollo, pruebas y documentaci\u00f3n de todo tipo de APIs, especialmente REST. Permite hacer todo el proceso de pruebas, incluso de automatizaci\u00f3n de estas, para ahorrar tiempo y tener una mejor cobertura. Ac\u00e1 vemos algunos enlaces para conocer y manejar muy bien esta herramienta: Tutorial definitivo de Postman: https://www.youtube.com/watch?v=qsejysrhJiU Postman tutorial: https://apidog.com/blog/how-to-use-postman-for-api-testing/ Empezamos creando un espacio de trabajo en postman (File -> New -> Workspace) Luego creamos una collection: En el \u00edcono Collections , le damos clic al bot\u00f3n Create new collections , como vemos en la imagen: Luego seleccionamos la opci\u00f3n Blank collection y le damos un nombre Y estamos listos para agregar peticiones. Hacemos clic en Add new request, para agergar la primera: En la pesta\u00f1a de la nueva petici\u00f3n, dejamos el m\u00e9todo GET y en la URL se pone el endpoint que dirige a ese m\u00e9todo en la api: http://localhost:8085/api/clientes Y estamos listos para agregar peticiones. Hacemos clic en Add new request, para agergar la primera: Ahora vamos a probar una petici\u00f3n POST (crear un cliente) Ahora vamos a probar una petici\u00f3n PUT (actualizar el cliente) Ahora vamos a probar una petici\u00f3n DELETE (eliminar un cliente)","title":"Backend API - Parte3"},{"location":"backendp3/#desarrollo-del-backend-api-i","text":"","title":"Desarrollo del Backend API (I)"},{"location":"backendp3/#creando-los-controladores","text":"En esta parte creamos los controladores que utilizaran los servicios. Los controladores son etiquetados con @RestController, que indica que la clase manejar\u00e1 peticiones de tipo REST. Este es un ejemplo del controlador de cliente: package com.example.rentacar.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import com.example.rentacar.entity.Cliente; import com.example.rentacar.service.IClienteServicio; import java.util.Optional; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.PutMapping; @RestController @RequestMapping(\"/api/clientes\") public class ClienteControlador { @Autowired private IClienteServicio clienteServicio; @GetMapping(\"/{id}\") public ResponseEntity<Cliente> getClientePorId(@PathVariable Integer id) { Optional<Cliente> opCliente = clienteServicio.obtenerClientePorId(id); if (opCliente.isPresent()) { return ResponseEntity.ok().body(opCliente.get()); } return ResponseEntity.notFound().build(); } @PostMapping public ResponseEntity<Cliente> crearCliente(@RequestBody Cliente entity) { Cliente nuevoCliente = clienteServicio.crearCliente(entity); return ResponseEntity.status(HttpStatus.CREATED).body(nuevoCliente); } @PutMapping(\"/{id}\") public ResponseEntity<Cliente> actualizarCliente(@PathVariable Integer id, @RequestBody Cliente clienteOld) { Optional<Cliente> cliente = clienteServicio.obtenerClientePorId(id); if (cliente.isPresent()) { Cliente clienteNew = cliente.get(); clienteNew.setDireccion(clienteOld.getDireccion()); clienteNew.setEmail(clienteOld.getEmail()); clienteNew.setNombre(clienteOld.getNombre()); clienteNew.setTelefono(clienteOld.getTelefono()); return ResponseEntity.ok(clienteServicio.crearCliente(clienteNew)); } return ResponseEntity.notFound().build(); } }","title":"Creando los controladores"},{"location":"backendp3/#configurar-la-conexion-a-la-base-de-datos","text":"Para conectarnos a la base de datos desde el backend, agregamos los siguientes datos al archivo de configuraci\u00f3n de la aplicaci\u00f3n, application.properties : #URL de conexi\u00f3n a la base de datos spring.datasource.url=jdbc:mysql://localhost:3307/rentacardb #Tipo de controlador de la BD spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect #Muestra en consola las consultas sql generadas spring.jpa.show-sql=true spring.datasource.username=root spring.datasource.password=root","title":"Configurar la conexi\u00f3n a la base de datos"},{"location":"backendp3/#ejecutando-la-aplicacion","text":"Para ejecutar la aplicaci\u00f3n tenemos varias opciones, la primera es ejecutar el wrapper de gradle , en la terminal, con el siguiente comando: gradlew.bat bootRun La otra opci\u00f3n es usar la extension Spring Boot Dashboard desde el \u00edcono Run de la aplicaci\u00f3n, como se ve en la imagen:","title":"Ejecutando la aplicaci\u00f3n"},{"location":"backendp3/#probando-el-backend-con-postman","text":"Postman , es una popular herramienta para desarrollo, pruebas y documentaci\u00f3n de todo tipo de APIs, especialmente REST. Permite hacer todo el proceso de pruebas, incluso de automatizaci\u00f3n de estas, para ahorrar tiempo y tener una mejor cobertura. Ac\u00e1 vemos algunos enlaces para conocer y manejar muy bien esta herramienta: Tutorial definitivo de Postman: https://www.youtube.com/watch?v=qsejysrhJiU Postman tutorial: https://apidog.com/blog/how-to-use-postman-for-api-testing/ Empezamos creando un espacio de trabajo en postman (File -> New -> Workspace) Luego creamos una collection: En el \u00edcono Collections , le damos clic al bot\u00f3n Create new collections , como vemos en la imagen: Luego seleccionamos la opci\u00f3n Blank collection y le damos un nombre Y estamos listos para agregar peticiones. Hacemos clic en Add new request, para agergar la primera: En la pesta\u00f1a de la nueva petici\u00f3n, dejamos el m\u00e9todo GET y en la URL se pone el endpoint que dirige a ese m\u00e9todo en la api: http://localhost:8085/api/clientes Y estamos listos para agregar peticiones. Hacemos clic en Add new request, para agergar la primera: Ahora vamos a probar una petici\u00f3n POST (crear un cliente) Ahora vamos a probar una petici\u00f3n PUT (actualizar el cliente) Ahora vamos a probar una petici\u00f3n DELETE (eliminar un cliente)","title":"Probando el Backend con Postman"},{"location":"backendp4/","text":"Desarrollo del Backend API (II) Asegurar las rutas del API Es importante proteger los endpoints de la api con el prop\u00f3sito de que no sean accesibles para cualquier usuario, principalmente, un usuario que no se haya autenticado en nuestra aplicaci\u00f3n. Hay varias formas de lograr esto. Nosotros utilizaremos un protocolo llamadno Json Web Token (JWT) , que es un m\u00e9todo popular para proteger las aplicaciones web modernas. Los JWT permiten transmitir informaci\u00f3n de forma segura entre partes como un objeto JSON compacto, aut\u00f3nomo y firmado digitalmente. JWT, por ser un protolo, se puede implementar en una amplia gama frameworks, de distintos tipos de lenguajes de programaci\u00f3n. Ac\u00e1 se puede encontrar m\u00e1s informaci\u00f3n sobre JWT: https://jwt.io/ Para la seguridad de un proyecto de spring (o spring boot) utilizaremos el proyecto/libreria Spring Security, del ecosistema Spring, y esto nos facilitar\u00e1 de manera sustancial, el trabajo que queremos hacer. Agregar la dependencia de Spring security al proyecto Agregar las dependencia por medio de la Extensi\u00f3n de VSCode Si instalamos la extensi\u00f3n spring boot gradle plus , vamos al buscador y escribimos los siguiente: > Add a dependency Sale una ventana como se ve en la imagen: En la ventana que sale, escribimos \"security\" y seleccionamos la dependencia spring-boot-starter-security Agregar la dependencia de forma manual Tambi\u00e9n podemos agregar la informaci\u00f3n de forma manual. En el archivo build.gradle agregamos la siguiente l\u00ednea en la secci\u00f3n de dependencias: implementation 'org.springframework.boot:spring-boot-starter-security' Agregar la dependencia de JWT para agregar la dependencia de JWT (una dependencia externa a Spring boot), agregamos la siguiente l\u00ednea a la secci\u00f3n de dependencias del archivo build.gradle: implementation 'org.springframework.boot:spring-boot-starter-security' implementation group: 'io.jsonwebtoken', name: 'jjwt-api', version: '0.12.6' runtimeOnly group: 'io.jsonwebtoken', name: 'jjwt-impl', version: '0.12.6' runtimeOnly group: 'io.jsonwebtoken', name: 'jjwt-jackson', version: '0.12.6' Desarrollar la seguridad en Spring boot En resumen, de la siguiente manera utilizaremos las tecnolog\u00edas y herramientas agregadas al proyecto: Con Spring Security, Creamos las clases para la configuraci\u00f3n de la aplicaci\u00f3n para la seguridad: ApplicationConfig, SecurityConfig. En estas clases se realiza el proceso de configuraci\u00f3n de seguridad los endpoints, cuales deben pasar por validaci\u00f3nd e token ( autenticated ) y cuales deben permitirse sin autenticaci\u00f3n ( permitAll ) Implementaci\u00f3n de interfaces que ayudan al proceso de autenticaci\u00f3n: User y UserDetails Implementaci\u00f3n del filtro de seguridad: OncePerRequestFilter (esto se hace en el filtro JwtAuthFilter) Con JsonWebToken hacemos el servicio de creaci\u00f3n y validaci\u00f3n del token (JwtServicio) Se crea la entidad de usuario con su respectivo repositorio Se crea el Servicio de usuario, que tendr\u00e1 el registro de usuario y el login El Controlador de usuario, para manejar las peticiones de las acciones anteriores. Clases de configuraci\u00f3n Creamos las clases de configuraci\u00f3n: ApplicationConfig, SecurityConfig //ApplicationConfig.java @Configuration public class ApplicationConfig { @Autowired private DetalleUsuarioServicio detalleUsuarioServicio; @Bean public BCryptPasswordEncoder decodificador() { return new BCryptPasswordEncoder(); }; @Bean public AuthenticationManager authenticationManager(HttpSecurity http, BCryptPasswordEncoder bCryptPasswordEncoder) throws Exception { AuthenticationManagerBuilder auth = http.getSharedObject(AuthenticationManagerBuilder.class); auth.userDetailsService(detalleUsuarioServicio).passwordEncoder(bCryptPasswordEncoder); return auth.build(); } } //SecurityConfig @Configuration @EnableWebSecurity @RequiredArgsConstructor public class SecurityConfig { @Autowired private JwtAuthFilter jwtAuthFilter; private static final String[] AUTH_WHITELIST = { \"/api/auth/login\", \"/api/auth/registro\" }; @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http .csrf(AbstractHttpConfigurer::disable) .authorizeRequests(authorizeRequests -> authorizeRequests.requestMatchers(AUTH_WHITELIST).permitAll() .anyRequest().authenticated()) .sessionManagement( sessionManagement -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class); return http.build(); } } El SecurityFilterChain es un filtro de servlet que es responsable de toda la seguridad (proteger las URL de la aplicaci\u00f3n, validar el nombre de usuario y las contrase\u00f1as enviadas, redirigir al formulario de inicio de sesi\u00f3n, etc.) dentro de su aplicaci\u00f3n. En la clase ApplicationConfig, se tiene el AuthenticationManager, que intenta autenticar el objeto de autenticaci\u00f3n pasado y devuelve un objeto de autenticaci\u00f3n completamente poblado (incluidas las autoridades otorgadas) si tiene \u00e9xito. Filtro y servicio Jsonwebtoken @Component @RequiredArgsConstructor public class JwtAuthFilter extends OncePerRequestFilter { @Autowired private JwtServicio servicioJwt; @Autowired private DetalleUsuarioServicio detalleUsuarioServicio; @Override protected void doFilterInternal(@SuppressWarnings(\"null\") HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { if (request.getServletPath().contains(\"/api/auth\")) { filterChain.doFilter(request, response); return; } String cabeceraAutorizacion = request.getHeader(\"Authorization\"); if (cabeceraAutorizacion == null || !cabeceraAutorizacion.startsWith(\"Bearer \")) { filterChain.doFilter(request, response); return; } String jwtToken = cabeceraAutorizacion.substring(\"Bearer \".length()); String nombreUsuario = servicioJwt.extraerUsuario(jwtToken); if (nombreUsuario != null && SecurityContextHolder.getContext().getAuthentication() == null) { UserDetails detalleUsuario = detalleUsuarioServicio.loadUserByUsername(nombreUsuario); if (servicioJwt.validarToken(jwtToken, detalleUsuario)) { UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken( detalleUsuario, null, detalleUsuario.getAuthorities()); authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); SecurityContextHolder.getContext().setAuthentication(authenticationToken); } } filterChain.doFilter(request, response); } } El filtro utiliza el servicio para validar las URLs del backend @Service public class JwtServicio { private final String USUARIO_CLAIM = \"usuario\"; private final String EXPIRACION_CLAIM = \"exp\"; @Value(\"${jwt.secret}\") private String secreto; public String extraerUsuario(String jwtToken) { final Claims claims = extraerTodosClaims(jwtToken); return claims.get(USUARIO_CLAIM, String.class); } private Claims extraerTodosClaims(String jwtToken) { return Jwts.parser().verifyWith(obtenerClaveDeFirma()).build().parseSignedClaims(jwtToken).getPayload(); } private SecretKey obtenerClaveDeFirma() { byte[] bytes = Decoders.BASE64.decode(secreto); return Keys.hmacShaKeyFor(bytes); } public boolean validarToken(String jwtToken, UserDetails detalleUsuario) { String usuario = extraerUsuario(jwtToken); return usuario.equals(detalleUsuario.getUsername()) && !esTokenExpirado(jwtToken); } private boolean esTokenExpirado(String jwtToken) { return extraerExpiracionToken(jwtToken).before(new Date()); } private Date extraerExpiracionToken(String jwtToken) { Claims claims = extraerTodosClaims(jwtToken); return claims.get(EXPIRACION_CLAIM, Date.class); } public String generarToken(Usuario usuario) { return crearToken(usuario); } private String crearToken(Usuario usuario) { return Jwts.builder().claim(USUARIO_CLAIM, usuario.getUsuario()) .issuedAt(new Date(System.currentTimeMillis())) .expiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 10)) .signWith(obtenerClaveDeFirma()) .compact(); } } El servicio JwtServicio implementa los m\u00e9todos necesarios para crear y validar tokens, as\u00ed como extraer de estos los reclamos (claims) de la carga \u00fatil. Hay que tener en cuenta que se debe registrar en el archivo properties, la propiedad de la variable secreto (jwt.secret), algo como esto: jwt.secret=9a4f2c8d3b7b1c5f47c3a0b2m387d8b1d4e6f3c8a9d2b5f8e3a9c8b5f6v8a3d9 Servicio de usuario y la implementaci\u00f3n de UserDetails @Service public class DetalleUsuarioServicio implements UserDetailsService { @Autowired private UsuarioRepositorio repoUsuario; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { return repoUsuario.findByUsuario(username) .map(user -> User.builder().username(user.getUsuario()) .password(user.getPassword()).build()) .orElseThrow(() -> new UsernameNotFoundException(\"Usuario no encontrado\")); } } @Service public class UsuarioServicioImpl implements IUsuarioServicio { private final BCryptPasswordEncoder codificadorPassword = new BCryptPasswordEncoder(); @Autowired private JwtServicio servicioJwt; @Autowired private AuthenticationManager managerAutenticacion; @Autowired private UsuarioRepositorio repo; @Override public UsuarioDTO registro(UsuarioDTO usuarioDto) { Usuario usuario = new Usuario(); usuario.setIdUsuario(usuarioDto.getIdUsuario()); usuario.setEmail(usuarioDto.getEmail()); usuario.setNombre(usuarioDto.getNombre()); usuario.setPassword(codificadorPassword.encode(usuarioDto.getPassword())); usuario.setUsuario(usuarioDto.getUsuario()); usuario = repo.save(usuario); return UsuarioDTO.builder() .email(usuario.getEmail()) .idUsuario(usuario.getIdUsuario()) .nombre(usuario.getNombre()) .usuario(usuario.getUsuario()) .password(usuario.getPassword()) .build(); } @Override public String login(LoginDTO login) { managerAutenticacion .authenticate(new UsernamePasswordAuthenticationToken(login.getUsuario(), login.getPassword())); Usuario usuario = repo.findByUsuario(login.getUsuario()) .orElseThrow(() -> new EntityNotFoundException(\"Usuario no encontrado\")); return servicioJwt.generarToken(usuario); } } La implementaci\u00f3n de la intefaz UserDetailsService se usa para tener acceso a los detalles del usuario que se loguea: usario, contrase\u00f1a, email, entre otros. La clase UsuarioServicio tiene los m\u00e9todos de registro de usuario en la base de datos y el m\u00e9todo de log\u00edn, que usa el Manejador de autenticaci\u00f3n AuthenticationManager Entidad usuario y repositorio @Entity @Data public class Usuario { @Id private Integer idUsuario; private String usuario; private String password; private String nombre; private String email; } public interface UsuarioRepositorio extends JpaRepository<Usuario, Integer> { Optional<Usuario> findByUsuario(String usuario); } En el repositorio de la entidad del Usuario, declaramos un m\u00e9todo para optener un usuario por su nombre de usuario (es decir, el atributo usuario). El Controlador de usuario y los DTO requeridos @RestController @RequestMapping(\"/api/auth\") @RequiredArgsConstructor public class UsuarioControlador { @Autowired private UsuarioServicioImpl usuarioServicio; @PostMapping(\"/registro\") public ResponseEntity<UsuarioDTO> registrarUsuario(@RequestBody UsuarioDTO entity) { UsuarioDTO usuarioDTO = usuarioServicio.registro(entity); return ResponseEntity.ok().body(usuarioDTO); } @PostMapping(\"/login\") public ResponseEntity<String> login(@RequestBody LoginDTO entity) { return ResponseEntity.ok().body(usuarioServicio.login(entity)); } } @AllArgsConstructor @NoArgsConstructor @Data @Builder public class UsuarioDTO { private Integer idUsuario; private String usuario; private String password; private String nombre; private String email; } @AllArgsConstructor @NoArgsConstructor @Data @Builder public class LoginDTO { private String usuario; private String password; } El controlador de usuario maneja los endpoint para el registro y el login del usuario Prueba de la seguridad de la api con Postman Luego de configurada la aplicaci\u00f3n, la ejecutamos y probamos la seguridad implementada: Hacemos una petici\u00f3n a una ruta protegida: Ejemplo GET clientes Consulta a una URL protegida Notamos que la respuesta es 403: Forbbiden, es decir, no tenemos permiso para acceder a ese recurso. Entonces debemos primero, registrar un usuario, si no tenemos, y loguearlo en la aplicaci\u00f3n para obtener el token: Registro de usuario Login de usuario para obtener el token Como ya registramos un usuario, vamos al endpoint de login para poder obtener el token de acceso a las URLs protegidas Ahora, utilizamos el token generado para poder acceder a las rutas protegidas: En la petici\u00f3n buscamos la pesta\u00f1a Autorization y ah\u00ed incluimos la cabecerar Bearer authentication , y agregamos el token y hacemos la petici\u00f3n. Ac\u00e1 solamente es ejecutar la petici\u00f3n y esperar la respuesta:","title":"Backend API - Parte4"},{"location":"backendp4/#desarrollo-del-backend-api-ii","text":"","title":"Desarrollo del Backend API (II)"},{"location":"backendp4/#asegurar-las-rutas-del-api","text":"Es importante proteger los endpoints de la api con el prop\u00f3sito de que no sean accesibles para cualquier usuario, principalmente, un usuario que no se haya autenticado en nuestra aplicaci\u00f3n. Hay varias formas de lograr esto. Nosotros utilizaremos un protocolo llamadno Json Web Token (JWT) , que es un m\u00e9todo popular para proteger las aplicaciones web modernas. Los JWT permiten transmitir informaci\u00f3n de forma segura entre partes como un objeto JSON compacto, aut\u00f3nomo y firmado digitalmente. JWT, por ser un protolo, se puede implementar en una amplia gama frameworks, de distintos tipos de lenguajes de programaci\u00f3n. Ac\u00e1 se puede encontrar m\u00e1s informaci\u00f3n sobre JWT: https://jwt.io/ Para la seguridad de un proyecto de spring (o spring boot) utilizaremos el proyecto/libreria Spring Security, del ecosistema Spring, y esto nos facilitar\u00e1 de manera sustancial, el trabajo que queremos hacer.","title":"Asegurar las rutas del API"},{"location":"backendp4/#agregar-la-dependencia-de-spring-security-al-proyecto","text":"","title":"Agregar la dependencia de Spring security al proyecto"},{"location":"backendp4/#agregar-las-dependencia-por-medio-de-la-extension-de-vscode","text":"Si instalamos la extensi\u00f3n spring boot gradle plus , vamos al buscador y escribimos los siguiente: > Add a dependency Sale una ventana como se ve en la imagen: En la ventana que sale, escribimos \"security\" y seleccionamos la dependencia spring-boot-starter-security","title":"Agregar las dependencia por medio de la Extensi\u00f3n de VSCode"},{"location":"backendp4/#agregar-la-dependencia-de-forma-manual","text":"Tambi\u00e9n podemos agregar la informaci\u00f3n de forma manual. En el archivo build.gradle agregamos la siguiente l\u00ednea en la secci\u00f3n de dependencias: implementation 'org.springframework.boot:spring-boot-starter-security'","title":"Agregar la dependencia de forma manual"},{"location":"backendp4/#agregar-la-dependencia-de-jwt","text":"para agregar la dependencia de JWT (una dependencia externa a Spring boot), agregamos la siguiente l\u00ednea a la secci\u00f3n de dependencias del archivo build.gradle: implementation 'org.springframework.boot:spring-boot-starter-security' implementation group: 'io.jsonwebtoken', name: 'jjwt-api', version: '0.12.6' runtimeOnly group: 'io.jsonwebtoken', name: 'jjwt-impl', version: '0.12.6' runtimeOnly group: 'io.jsonwebtoken', name: 'jjwt-jackson', version: '0.12.6'","title":"Agregar la dependencia de JWT"},{"location":"backendp4/#desarrollar-la-seguridad-en-spring-boot","text":"En resumen, de la siguiente manera utilizaremos las tecnolog\u00edas y herramientas agregadas al proyecto: Con Spring Security, Creamos las clases para la configuraci\u00f3n de la aplicaci\u00f3n para la seguridad: ApplicationConfig, SecurityConfig. En estas clases se realiza el proceso de configuraci\u00f3n de seguridad los endpoints, cuales deben pasar por validaci\u00f3nd e token ( autenticated ) y cuales deben permitirse sin autenticaci\u00f3n ( permitAll ) Implementaci\u00f3n de interfaces que ayudan al proceso de autenticaci\u00f3n: User y UserDetails Implementaci\u00f3n del filtro de seguridad: OncePerRequestFilter (esto se hace en el filtro JwtAuthFilter) Con JsonWebToken hacemos el servicio de creaci\u00f3n y validaci\u00f3n del token (JwtServicio) Se crea la entidad de usuario con su respectivo repositorio Se crea el Servicio de usuario, que tendr\u00e1 el registro de usuario y el login El Controlador de usuario, para manejar las peticiones de las acciones anteriores.","title":"Desarrollar la seguridad en Spring boot"},{"location":"backendp4/#clases-de-configuracion","text":"Creamos las clases de configuraci\u00f3n: ApplicationConfig, SecurityConfig //ApplicationConfig.java @Configuration public class ApplicationConfig { @Autowired private DetalleUsuarioServicio detalleUsuarioServicio; @Bean public BCryptPasswordEncoder decodificador() { return new BCryptPasswordEncoder(); }; @Bean public AuthenticationManager authenticationManager(HttpSecurity http, BCryptPasswordEncoder bCryptPasswordEncoder) throws Exception { AuthenticationManagerBuilder auth = http.getSharedObject(AuthenticationManagerBuilder.class); auth.userDetailsService(detalleUsuarioServicio).passwordEncoder(bCryptPasswordEncoder); return auth.build(); } } //SecurityConfig @Configuration @EnableWebSecurity @RequiredArgsConstructor public class SecurityConfig { @Autowired private JwtAuthFilter jwtAuthFilter; private static final String[] AUTH_WHITELIST = { \"/api/auth/login\", \"/api/auth/registro\" }; @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http .csrf(AbstractHttpConfigurer::disable) .authorizeRequests(authorizeRequests -> authorizeRequests.requestMatchers(AUTH_WHITELIST).permitAll() .anyRequest().authenticated()) .sessionManagement( sessionManagement -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class); return http.build(); } } El SecurityFilterChain es un filtro de servlet que es responsable de toda la seguridad (proteger las URL de la aplicaci\u00f3n, validar el nombre de usuario y las contrase\u00f1as enviadas, redirigir al formulario de inicio de sesi\u00f3n, etc.) dentro de su aplicaci\u00f3n. En la clase ApplicationConfig, se tiene el AuthenticationManager, que intenta autenticar el objeto de autenticaci\u00f3n pasado y devuelve un objeto de autenticaci\u00f3n completamente poblado (incluidas las autoridades otorgadas) si tiene \u00e9xito.","title":"Clases de configuraci\u00f3n"},{"location":"backendp4/#filtro-y-servicio-jsonwebtoken","text":"@Component @RequiredArgsConstructor public class JwtAuthFilter extends OncePerRequestFilter { @Autowired private JwtServicio servicioJwt; @Autowired private DetalleUsuarioServicio detalleUsuarioServicio; @Override protected void doFilterInternal(@SuppressWarnings(\"null\") HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { if (request.getServletPath().contains(\"/api/auth\")) { filterChain.doFilter(request, response); return; } String cabeceraAutorizacion = request.getHeader(\"Authorization\"); if (cabeceraAutorizacion == null || !cabeceraAutorizacion.startsWith(\"Bearer \")) { filterChain.doFilter(request, response); return; } String jwtToken = cabeceraAutorizacion.substring(\"Bearer \".length()); String nombreUsuario = servicioJwt.extraerUsuario(jwtToken); if (nombreUsuario != null && SecurityContextHolder.getContext().getAuthentication() == null) { UserDetails detalleUsuario = detalleUsuarioServicio.loadUserByUsername(nombreUsuario); if (servicioJwt.validarToken(jwtToken, detalleUsuario)) { UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken( detalleUsuario, null, detalleUsuario.getAuthorities()); authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); SecurityContextHolder.getContext().setAuthentication(authenticationToken); } } filterChain.doFilter(request, response); } } El filtro utiliza el servicio para validar las URLs del backend @Service public class JwtServicio { private final String USUARIO_CLAIM = \"usuario\"; private final String EXPIRACION_CLAIM = \"exp\"; @Value(\"${jwt.secret}\") private String secreto; public String extraerUsuario(String jwtToken) { final Claims claims = extraerTodosClaims(jwtToken); return claims.get(USUARIO_CLAIM, String.class); } private Claims extraerTodosClaims(String jwtToken) { return Jwts.parser().verifyWith(obtenerClaveDeFirma()).build().parseSignedClaims(jwtToken).getPayload(); } private SecretKey obtenerClaveDeFirma() { byte[] bytes = Decoders.BASE64.decode(secreto); return Keys.hmacShaKeyFor(bytes); } public boolean validarToken(String jwtToken, UserDetails detalleUsuario) { String usuario = extraerUsuario(jwtToken); return usuario.equals(detalleUsuario.getUsername()) && !esTokenExpirado(jwtToken); } private boolean esTokenExpirado(String jwtToken) { return extraerExpiracionToken(jwtToken).before(new Date()); } private Date extraerExpiracionToken(String jwtToken) { Claims claims = extraerTodosClaims(jwtToken); return claims.get(EXPIRACION_CLAIM, Date.class); } public String generarToken(Usuario usuario) { return crearToken(usuario); } private String crearToken(Usuario usuario) { return Jwts.builder().claim(USUARIO_CLAIM, usuario.getUsuario()) .issuedAt(new Date(System.currentTimeMillis())) .expiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 10)) .signWith(obtenerClaveDeFirma()) .compact(); } } El servicio JwtServicio implementa los m\u00e9todos necesarios para crear y validar tokens, as\u00ed como extraer de estos los reclamos (claims) de la carga \u00fatil. Hay que tener en cuenta que se debe registrar en el archivo properties, la propiedad de la variable secreto (jwt.secret), algo como esto: jwt.secret=9a4f2c8d3b7b1c5f47c3a0b2m387d8b1d4e6f3c8a9d2b5f8e3a9c8b5f6v8a3d9","title":"Filtro y servicio Jsonwebtoken"},{"location":"backendp4/#servicio-de-usuario-y-la-implementacion-de-userdetails","text":"@Service public class DetalleUsuarioServicio implements UserDetailsService { @Autowired private UsuarioRepositorio repoUsuario; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { return repoUsuario.findByUsuario(username) .map(user -> User.builder().username(user.getUsuario()) .password(user.getPassword()).build()) .orElseThrow(() -> new UsernameNotFoundException(\"Usuario no encontrado\")); } } @Service public class UsuarioServicioImpl implements IUsuarioServicio { private final BCryptPasswordEncoder codificadorPassword = new BCryptPasswordEncoder(); @Autowired private JwtServicio servicioJwt; @Autowired private AuthenticationManager managerAutenticacion; @Autowired private UsuarioRepositorio repo; @Override public UsuarioDTO registro(UsuarioDTO usuarioDto) { Usuario usuario = new Usuario(); usuario.setIdUsuario(usuarioDto.getIdUsuario()); usuario.setEmail(usuarioDto.getEmail()); usuario.setNombre(usuarioDto.getNombre()); usuario.setPassword(codificadorPassword.encode(usuarioDto.getPassword())); usuario.setUsuario(usuarioDto.getUsuario()); usuario = repo.save(usuario); return UsuarioDTO.builder() .email(usuario.getEmail()) .idUsuario(usuario.getIdUsuario()) .nombre(usuario.getNombre()) .usuario(usuario.getUsuario()) .password(usuario.getPassword()) .build(); } @Override public String login(LoginDTO login) { managerAutenticacion .authenticate(new UsernamePasswordAuthenticationToken(login.getUsuario(), login.getPassword())); Usuario usuario = repo.findByUsuario(login.getUsuario()) .orElseThrow(() -> new EntityNotFoundException(\"Usuario no encontrado\")); return servicioJwt.generarToken(usuario); } } La implementaci\u00f3n de la intefaz UserDetailsService se usa para tener acceso a los detalles del usuario que se loguea: usario, contrase\u00f1a, email, entre otros. La clase UsuarioServicio tiene los m\u00e9todos de registro de usuario en la base de datos y el m\u00e9todo de log\u00edn, que usa el Manejador de autenticaci\u00f3n AuthenticationManager","title":"Servicio de usuario y la implementaci\u00f3n de UserDetails"},{"location":"backendp4/#entidad-usuario-y-repositorio","text":"@Entity @Data public class Usuario { @Id private Integer idUsuario; private String usuario; private String password; private String nombre; private String email; } public interface UsuarioRepositorio extends JpaRepository<Usuario, Integer> { Optional<Usuario> findByUsuario(String usuario); } En el repositorio de la entidad del Usuario, declaramos un m\u00e9todo para optener un usuario por su nombre de usuario (es decir, el atributo usuario).","title":"Entidad usuario y repositorio"},{"location":"backendp4/#el-controlador-de-usuario-y-los-dto-requeridos","text":"@RestController @RequestMapping(\"/api/auth\") @RequiredArgsConstructor public class UsuarioControlador { @Autowired private UsuarioServicioImpl usuarioServicio; @PostMapping(\"/registro\") public ResponseEntity<UsuarioDTO> registrarUsuario(@RequestBody UsuarioDTO entity) { UsuarioDTO usuarioDTO = usuarioServicio.registro(entity); return ResponseEntity.ok().body(usuarioDTO); } @PostMapping(\"/login\") public ResponseEntity<String> login(@RequestBody LoginDTO entity) { return ResponseEntity.ok().body(usuarioServicio.login(entity)); } } @AllArgsConstructor @NoArgsConstructor @Data @Builder public class UsuarioDTO { private Integer idUsuario; private String usuario; private String password; private String nombre; private String email; } @AllArgsConstructor @NoArgsConstructor @Data @Builder public class LoginDTO { private String usuario; private String password; } El controlador de usuario maneja los endpoint para el registro y el login del usuario","title":"El Controlador de usuario y los DTO requeridos"},{"location":"backendp4/#prueba-de-la-seguridad-de-la-api-con-postman","text":"Luego de configurada la aplicaci\u00f3n, la ejecutamos y probamos la seguridad implementada: Hacemos una petici\u00f3n a una ruta protegida: Ejemplo GET clientes","title":"Prueba de la seguridad de la api con Postman"},{"location":"backendp4/#consulta-a-una-url-protegida","text":"Notamos que la respuesta es 403: Forbbiden, es decir, no tenemos permiso para acceder a ese recurso. Entonces debemos primero, registrar un usuario, si no tenemos, y loguearlo en la aplicaci\u00f3n para obtener el token:","title":"Consulta a una URL protegida"},{"location":"backendp4/#registro-de-usuario","text":"","title":"Registro de usuario"},{"location":"backendp4/#login-de-usuario-para-obtener-el-token","text":"Como ya registramos un usuario, vamos al endpoint de login para poder obtener el token de acceso a las URLs protegidas Ahora, utilizamos el token generado para poder acceder a las rutas protegidas: En la petici\u00f3n buscamos la pesta\u00f1a Autorization y ah\u00ed incluimos la cabecerar Bearer authentication , y agregamos el token y hacemos la petici\u00f3n. Ac\u00e1 solamente es ejecutar la petici\u00f3n y esperar la respuesta:","title":"Login de usuario para obtener el token"},{"location":"backendp5/","text":"Despliegue del backend con Docker Una vez finalizado todo el desarrollo del backend, vamos a automatizar el despliegue de este componente con docker. Ya vimos algo de este proceso cuando contenerizamos la base de datos. Preparar el proyecto para \"Empaquetar\" Lo primero que debemos hacer es generar el archivo JAR o WAR de ejecuci\u00f3n de la aplicaci\u00f3n. Para esto, con gradle ejecutamos el siguiente comando: ./gradlew bootJar Esto generar\u00e1 un archivo .jar en el directorio build/libs/ (por ejemplo, build/libs/rentacar-0.0.1-SNAPSHOT.jar). Crear el archivo Dockerfile El archivo Dockerfile crea la imagen del contenedor para nuestra aplicaci\u00f3n, el siguiente es el c\u00f3digo de ese archivo para el proyecto: # Usa una imagen base con Java FROM eclipse-temurin:23-jdk-alpine # Crea un directorio para la aplicaci\u00f3n WORKDIR /app # Copia el archivo JAR generado por Gradle al contenedor COPY build/libs/rentacar-0.0.1-SNAPSHOT.jar app.jar # Expone el puerto en el que tu aplicaci\u00f3n se ejecutar\u00e1 EXPOSE 8080 # Comando para ejecutar la aplicaci\u00f3n ENTRYPOINT [\"java\", \"-jar\", \"app.jar\"] Crear el archivo .dockerignore El archivo .dockerignore se utiliza para excluir archivos y carpetas innecesarias al construir la imagen: build/ .gradle/ *.git *.idea logs/ Construir la imagen En la raiz del proyecto, donde creamos el Dockerfile, ejecutamos el comando para construir la imagen: docker build -t rentacar-be . Ejecutar el contenedor Una vez creada la imagen, si no se nos presenta alg\u00fan problema, podemos ejecutar el contendor con el siguiente comando: docker run -d --name rentacar-be -p 8085:8085/tcp rentacar-be Este comando no ayuda a crear y ejecutar un contenedor basado en la imagen de la aplicaci\u00f3n. Al ejecutar el contenedor, debe salir en la terminal el ID del contenedor, si no se present\u00f3 ning\u00fan error. Si ejecutamos la aplicaci\u00f3n, probamos el postman el login, nos sale el siguiente error: Podemos revisar los errores que se presenten en las aplicaciones dentro de los contenedores. Con el siguiente comando podemos ver los logs de la aplicaci\u00f3n ejecut\u00e1ndose en el contenedor: docker logs rentacar-be Podemos ver, al final del log un error similar al siguiente: The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server. at java.base/jdk.internal.reflect.DirectConstructorHandleAccessor.newInstance(DirectConstructorHandleAccessor.java:62) ~[na:na] at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:501) ~[na:na] at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:485) ~[na:na] at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61) ~[mysql-connector-j-8.3.0.jar!/:8.3.0] at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:104) ~[mysql-connector-j-8.3.0.jar!/:8.3.0] at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:149) ~[mysql-connector-j-8.3.0.jar!/:8.3.0] at com.mysql.cj.exceptions.ExceptionFactory.createCommunicationsException(ExceptionFactory.java:165) ~[mysql-connector-j-8.3.0.jar!/:8.3.0] at com.mysql.cj.protocol.a.NativeSocketConnection.connect(NativeSocketConnection.java:88) ~[mysql-connector-j-8.3.0.jar!/:8.3.0] at com.mysql.cj.NativeSession.connect(NativeSession.java:120) ~[mysql-connector-j-8.3.0.jar!/:8.3.0] at com.mysql.cj.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:935) ~[mysql-connector-j-8.3.0.jar!/:8.3.0] at com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:805) ~[mysql-connector-j-8.3.0.jar!/:8.3.0] ... 139 common frames omitted Caused by: java.net.ConnectException: Connection refused at java.base/sun.nio.ch.Net.pollConnect(Native Method) ~[na:na] at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:682) ~[na:na] at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:542) ~[na:na] at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:592) ~[na:na] at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327) ~[na:na] at java.base/java.net.Socket.connect(Socket.java:760) ~[na:na] at com.mysql.cj.protocol.StandardSocketFactory.connect(StandardSocketFactory.java:153) ~[mysql-connector-j-8.3.0.jar!/:8.3.0] at com.mysql.cj.protocol.a.NativeSocketConnection.connect(NativeSocketConnection.java:62) ~[mysql-connector-j-8.3.0.jar!/:8.3.0] ... 142 common frames omitted Este error se debe a que el contenedor del backend no est\u00e1 accediendo a la base de datos que est\u00e1 en su propio contenedor, no en el host. Para corregir esto debemos hacer dos cosas: primero, agregar el contenedor de docker en el script del docker compose y agregarlo a la misma red del contenedor de la base de datos, y segundo, cambiar la l\u00ednea de conexi\u00f3n a la base de datos en el application.properties: Agregar el backend al docker compose Ajustamos el archivo docker-compose.yml anterior para agregar la informaci\u00f3n del backend: services: mysql: image: mysql container_name: mysql ports: - 3307:3306 networks: - redfullstack environment: - MYSQL_ROOT_PASSWORD=root - MYSQL_DATABASE=rentacardb - MYSQL_USER=admin - MYSQL_PASSWORD=admin volumes: - mysql_data:/var/lib/mysql phpmyadmin: image: phpmyadmin environment: - PMA_HOST=mysql depends_on: - mysql container_name: phpmyadmin ports: - 8180:80 networks: - redfullstack rentacar_be: image: rentacar-be container_name: rentacar_be restart: always ports: - 8085:8085 networks: - redfullstack depends_on: - mysql networks: redfullstack: driver: bridge volumes: mysql_data: Cambiar la configuraci\u00f3n de conexi\u00f3n a la base de datos Ahora, debemos cambiar la configuraci\u00f3n conexi\u00f3n a la base de datos en el backend, en el archivo properties, cambiamos la l\u00ednea: spring.datasource.url=jdbc:mysql://localhost:3307/rentacardb Por esta: spring.datasource.url=jdbc:mysql://mysql:3306/rentacardb Ejecutar todo junto Ahora solamente es compilar nuevamente el backend y recrear la imagen con el nuevo cambio y luego ejecutar el docker compose: ./gradlew bootJar docker build -t rentacar-be . docker compose up -d Probando todo junto Una vez se ejecuta el docker compose, con los contenedores arriba, procedemos a hacer pruebas:","title":"Backend API - Parte5"},{"location":"backendp5/#despliegue-del-backend-con-docker","text":"Una vez finalizado todo el desarrollo del backend, vamos a automatizar el despliegue de este componente con docker. Ya vimos algo de este proceso cuando contenerizamos la base de datos.","title":"Despliegue del backend con Docker"},{"location":"backendp5/#preparar-el-proyecto-para-empaquetar","text":"Lo primero que debemos hacer es generar el archivo JAR o WAR de ejecuci\u00f3n de la aplicaci\u00f3n. Para esto, con gradle ejecutamos el siguiente comando: ./gradlew bootJar Esto generar\u00e1 un archivo .jar en el directorio build/libs/ (por ejemplo, build/libs/rentacar-0.0.1-SNAPSHOT.jar).","title":"Preparar el proyecto para \"Empaquetar\""},{"location":"backendp5/#crear-el-archivo-dockerfile","text":"El archivo Dockerfile crea la imagen del contenedor para nuestra aplicaci\u00f3n, el siguiente es el c\u00f3digo de ese archivo para el proyecto: # Usa una imagen base con Java FROM eclipse-temurin:23-jdk-alpine # Crea un directorio para la aplicaci\u00f3n WORKDIR /app # Copia el archivo JAR generado por Gradle al contenedor COPY build/libs/rentacar-0.0.1-SNAPSHOT.jar app.jar # Expone el puerto en el que tu aplicaci\u00f3n se ejecutar\u00e1 EXPOSE 8080 # Comando para ejecutar la aplicaci\u00f3n ENTRYPOINT [\"java\", \"-jar\", \"app.jar\"]","title":"Crear el archivo Dockerfile"},{"location":"backendp5/#crear-el-archivo-dockerignore","text":"El archivo .dockerignore se utiliza para excluir archivos y carpetas innecesarias al construir la imagen: build/ .gradle/ *.git *.idea logs/","title":"Crear el archivo .dockerignore"},{"location":"backendp5/#construir-la-imagen","text":"En la raiz del proyecto, donde creamos el Dockerfile, ejecutamos el comando para construir la imagen: docker build -t rentacar-be .","title":"Construir la imagen"},{"location":"backendp5/#ejecutar-el-contenedor","text":"Una vez creada la imagen, si no se nos presenta alg\u00fan problema, podemos ejecutar el contendor con el siguiente comando: docker run -d --name rentacar-be -p 8085:8085/tcp rentacar-be Este comando no ayuda a crear y ejecutar un contenedor basado en la imagen de la aplicaci\u00f3n. Al ejecutar el contenedor, debe salir en la terminal el ID del contenedor, si no se present\u00f3 ning\u00fan error. Si ejecutamos la aplicaci\u00f3n, probamos el postman el login, nos sale el siguiente error: Podemos revisar los errores que se presenten en las aplicaciones dentro de los contenedores. Con el siguiente comando podemos ver los logs de la aplicaci\u00f3n ejecut\u00e1ndose en el contenedor: docker logs rentacar-be Podemos ver, al final del log un error similar al siguiente: The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server. at java.base/jdk.internal.reflect.DirectConstructorHandleAccessor.newInstance(DirectConstructorHandleAccessor.java:62) ~[na:na] at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:501) ~[na:na] at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:485) ~[na:na] at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:61) ~[mysql-connector-j-8.3.0.jar!/:8.3.0] at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:104) ~[mysql-connector-j-8.3.0.jar!/:8.3.0] at com.mysql.cj.exceptions.ExceptionFactory.createException(ExceptionFactory.java:149) ~[mysql-connector-j-8.3.0.jar!/:8.3.0] at com.mysql.cj.exceptions.ExceptionFactory.createCommunicationsException(ExceptionFactory.java:165) ~[mysql-connector-j-8.3.0.jar!/:8.3.0] at com.mysql.cj.protocol.a.NativeSocketConnection.connect(NativeSocketConnection.java:88) ~[mysql-connector-j-8.3.0.jar!/:8.3.0] at com.mysql.cj.NativeSession.connect(NativeSession.java:120) ~[mysql-connector-j-8.3.0.jar!/:8.3.0] at com.mysql.cj.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:935) ~[mysql-connector-j-8.3.0.jar!/:8.3.0] at com.mysql.cj.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:805) ~[mysql-connector-j-8.3.0.jar!/:8.3.0] ... 139 common frames omitted Caused by: java.net.ConnectException: Connection refused at java.base/sun.nio.ch.Net.pollConnect(Native Method) ~[na:na] at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:682) ~[na:na] at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:542) ~[na:na] at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:592) ~[na:na] at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327) ~[na:na] at java.base/java.net.Socket.connect(Socket.java:760) ~[na:na] at com.mysql.cj.protocol.StandardSocketFactory.connect(StandardSocketFactory.java:153) ~[mysql-connector-j-8.3.0.jar!/:8.3.0] at com.mysql.cj.protocol.a.NativeSocketConnection.connect(NativeSocketConnection.java:62) ~[mysql-connector-j-8.3.0.jar!/:8.3.0] ... 142 common frames omitted Este error se debe a que el contenedor del backend no est\u00e1 accediendo a la base de datos que est\u00e1 en su propio contenedor, no en el host. Para corregir esto debemos hacer dos cosas: primero, agregar el contenedor de docker en el script del docker compose y agregarlo a la misma red del contenedor de la base de datos, y segundo, cambiar la l\u00ednea de conexi\u00f3n a la base de datos en el application.properties:","title":"Ejecutar el contenedor"},{"location":"backendp5/#agregar-el-backend-al-docker-compose","text":"Ajustamos el archivo docker-compose.yml anterior para agregar la informaci\u00f3n del backend: services: mysql: image: mysql container_name: mysql ports: - 3307:3306 networks: - redfullstack environment: - MYSQL_ROOT_PASSWORD=root - MYSQL_DATABASE=rentacardb - MYSQL_USER=admin - MYSQL_PASSWORD=admin volumes: - mysql_data:/var/lib/mysql phpmyadmin: image: phpmyadmin environment: - PMA_HOST=mysql depends_on: - mysql container_name: phpmyadmin ports: - 8180:80 networks: - redfullstack rentacar_be: image: rentacar-be container_name: rentacar_be restart: always ports: - 8085:8085 networks: - redfullstack depends_on: - mysql networks: redfullstack: driver: bridge volumes: mysql_data:","title":"Agregar el backend al docker compose"},{"location":"backendp5/#cambiar-la-configuracion-de-conexion-a-la-base-de-datos","text":"Ahora, debemos cambiar la configuraci\u00f3n conexi\u00f3n a la base de datos en el backend, en el archivo properties, cambiamos la l\u00ednea: spring.datasource.url=jdbc:mysql://localhost:3307/rentacardb Por esta: spring.datasource.url=jdbc:mysql://mysql:3306/rentacardb","title":"Cambiar la configuraci\u00f3n de conexi\u00f3n a la base de datos"},{"location":"backendp5/#ejecutar-todo-junto","text":"Ahora solamente es compilar nuevamente el backend y recrear la imagen con el nuevo cambio y luego ejecutar el docker compose: ./gradlew bootJar docker build -t rentacar-be . docker compose up -d","title":"Ejecutar todo junto"},{"location":"backendp5/#probando-todo-junto","text":"Una vez se ejecuta el docker compose, con los contenedores arriba, procedemos a hacer pruebas:","title":"Probando todo junto"},{"location":"basedatos/","text":"Base de datos La base de datos es parte fundamental de la aplicaci\u00f3n. En esta escenario vamos a mostrar un esquema relacional de los datos del negocio: Una renta de autos. Clientes: Informaci\u00f3n de los clientes que rentan autos. Autos: Informaci\u00f3n de los autos disponibles para renta. Rentas: Informaci\u00f3n de las rentas realizadas. Pagos: Informaci\u00f3n de los pagos realizados por las rentas. Usuarios: una tabla usuarios para hacer el proceso de registro y acceso a la aplicaci\u00f3n. Relaciones: Clientes -> Rentas: Un cliente puede tener m\u00faltiples rentas. Autos -> Rentas: Un auto puede ser rentado m\u00faltiples veces. Rentas -> Pagos: Cada renta puede tener uno o m\u00e1s pagos. Esquema Relacional: Clientes (1) <--> (M) Rentas Autos (1) <--> (M) Rentas Rentas (1) <--> (M) Pagos Crear el modelo de base de datos Utilizaremos el siguiente script inicial para crear la base de datos en mysql, el nombre de la base de datos ser\u00e1 rentacardb . DROP DATABASE IF EXISTS rentacardb; CREATE DATABASE rentacardb; USE rentacardb; DROP TABLE IF EXISTS cliente; CREATE TABLE cliente ( id_cliente int NOT NULL AUTO_INCREMENT, direccion varchar(255) DEFAULT NULL, email varchar(255) DEFAULT NULL, nombre varchar(255) DEFAULT NULL, telefono varchar(255) DEFAULT NULL, PRIMARY KEY (id_cliente) ); DROP TABLE IF EXISTS vehiculo; CREATE TABLE vehiculo ( anio int DEFAULT NULL, id_vehiculo int NOT NULL AUTO_INCREMENT, precio double DEFAULT NULL, marca varchar(255) DEFAULT NULL, modelo varchar(255) DEFAULT NULL, estado enum('Disponible','En_Mantenimiento','Rentado') DEFAULT NULL, tipo enum('Camioneta','Compacto','Deportivo','SUV','Sedan') DEFAULT NULL, PRIMARY KEY (id_vehiculo) ); DROP TABLE IF EXISTS reserva; CREATE TABLE reserva ( fecha_fin date DEFAULT NULL, fecha_inicio date DEFAULT NULL, id_cliente int DEFAULT NULL, id_empleado int DEFAULT NULL, id_reserva int NOT NULL, id_vehiculo int DEFAULT NULL, total double DEFAULT NULL, PRIMARY KEY (id_reserva), FOREIGN KEY (id_cliente) REFERENCES cliente (id_cliente), FOREIGN KEY (id_vehiculo) REFERENCES vehiculo (id_vehiculo) ); DROP TABLE IF EXISTS pago; CREATE TABLE pago ( id_pago int NOT NULL AUTO_INCREMENT, id_reserva int DEFAULT NULL, metodo_pago enum('Efectivo','Debito','Credito','Transferencia') DEFAULT NULL, valor double DEFAULT NULL, fecha_pago datetime(6) DEFAULT NULL, PRIMARY KEY (id_pago), KEY id_reserva (id_reserva), CONSTRAINT pago_ibfk_1 FOREIGN KEY (id_reserva) REFERENCES reserva (id_reserva) ); DROP TABLE IF EXISTS usuario; CREATE TABLE usuario ( idusuario int NOT NULL AUTO_INCREMENT, usuario varchar(45) NOT NULL, contrasena varchar(200) NOT NULL, nombre varchar(45) DEFAULT NULL, PRIMARY KEY (idusuario), UNIQUE KEY usuario_UNIQUE (usuario) ); Desplegar la base de datos: Docker Utilizaremos docker para poder desplegar la base de datos. Docker es un proyecto de c\u00f3digo abierto que automatiza el despliegue de aplicaciones dentro de contenedores de software, proporcionando una capa adicional de abstracci\u00f3n y automatizaci\u00f3n de virtualizaci\u00f3n de aplicaciones en m\u00faltiples sistemas operativos. Docker utiliza caracter\u00edsticas de aislamiento de recursos del kernel Linux, tales como cgroups y espacios de nombres (namespaces) para permitir que 'contenedores' independientes se ejecuten dentro de una sola instancia de Linux, evitando la sobrecarga de iniciar y mantener m\u00e1quinas virtuales. Ac\u00e1 hay un video que explica muy bien el tema de docker, y lo mejor es que es para personas que no tienen conocimiento de esta tecnolog\u00eda: https://www.youtube.com/watch?v=CV_Uf3Dq-EU Instalaci\u00f3n de docker Antes de empezar con Docker, primero necesitamos instalarlo. A continuaci\u00f3n hay unos enlaces que describen la instalaci\u00f3n, dependiendo del Sistema Operativo: Docker en windows Docker en Linux (Ubuntu) Docker en Mac Crear las instancias de mysql y el cliente para mysql Creamos una instancia de una imagen de mysql con el siguiente comando: docker run --name mysql -e MYSQL_ROOT_PASSWORD=secret -e MYSQL_ROOT_HOST=% -p 127.0.0.1:3307:3306/tcp -d mysql:latest Si todo sale bien, en consola muestra el ID del contenedor: Para conectarnos a la base de datos anterior, necesitamos una aplicaci\u00f3n cliente (Ej. Mysql Workbench, consola de mysql, PhpMyAdmin, etc). PhpMyadmin es un cliente de mysql muy popular, basado en php (utiliza un servidor apache HTTP). Podemos crear un contenedor de docker que tenga, por ejemplo, phpmyadmin: docker run --name phpmyadmin -d --link mysql:db -p 8180:80 phpmyadmin Con esto, ya podemos acceder al servidor de phpmyadmin y luego a la base de datos: Crear el contenedor de mysql persistente Con el comando ejecutado para crear el contenedor de la base de datos, esta por defecto no almacena los datos de forma persistente. Una vez se apague o detenga el contenedor, los datos guardados (tablas creadas, vistas, etc) ser\u00e1n borrados. Debemos agregar al comando algunas opciones para que se pueda guadar la informaci\u00f3n incluso cuando se apague el contenedor. La opci\u00f3n principal para esto es agregar un volumen al contenedor, un espacion en \u00e9l para que pueda guardar informaci\u00f3n que genera la aplicaci\u00f3n contenida. Entonces modificamos el comando para que se ejecute lo siguiente: -- primero se detiene el contenedor docker stop mysql -- ahora el comando para persistir los datos en el contenedor docker run --name mysql -e MYSQL_ROOT_PASSWORD=secret -e MYSQL_ROOT_HOST=% -p 127.0.0.1:3307:3306/tcp -v \"C:/Ejemplos/docker/mysql:/var/lib/mysql\" -d mysql:latest En la carpeta del Host configurada como volumen, nos ha creado algunos archivos: Utilizar Docker-Compose Docker-Compose es una herramienta que permite manejar aplicaciones Docker. Con Docker-Compose se pueden definir y ejecutar aplicaciones multi-contenedores. En lugar de ejecutar los contenedores uno por uno con la l\u00ednea de comandos de Docker, se puede crear un archivo YAML para definir todos los servicios, redes y vol\u00famenes necesarios para tu aplicaci\u00f3n. En este enlace puede saber m\u00e1s acerca de docker compose: \u00bfQu\u00e9 es Docker Compose? Vamos a crear un archivo docker-compose.yml para definir y ejecutar el servicio de mysql, y el cliente phpmyadmin: services: mysql: image: mysql container_name: mysql ports: - 3307:3306 environment: - MYSQL_ROOT_PASSWORD=root - MYSQL_DATABASE=rentacardb - MYSQL_USER=admin - MYSQL_PASSWORD=admin volumes: - mysql_data:/var/lib/mysql phpmyadmin: image: phpmyadmin environment: - PMA_HOST=mysql depends_on: - mysql container_name: phpmyadmin ports: - 8180:80 volumes: mysql_data: Crear los objetos en la base de datos Ahora con el cliente de phpmyadmin, creamos la base de datos rentacardb y ejecutamos el script de creaci\u00f3n de tablas: En la ventana de phpmyadmin, le damos clic en la pesta\u00f1a SQL y ah\u00ed pegamos y ejecutamos nuestro c\u00f3digo y le damos clic en Continuar: Ahora podemos proceder a crear nuestro backend.","title":"Base de datos"},{"location":"basedatos/#base-de-datos","text":"La base de datos es parte fundamental de la aplicaci\u00f3n. En esta escenario vamos a mostrar un esquema relacional de los datos del negocio: Una renta de autos. Clientes: Informaci\u00f3n de los clientes que rentan autos. Autos: Informaci\u00f3n de los autos disponibles para renta. Rentas: Informaci\u00f3n de las rentas realizadas. Pagos: Informaci\u00f3n de los pagos realizados por las rentas. Usuarios: una tabla usuarios para hacer el proceso de registro y acceso a la aplicaci\u00f3n. Relaciones: Clientes -> Rentas: Un cliente puede tener m\u00faltiples rentas. Autos -> Rentas: Un auto puede ser rentado m\u00faltiples veces. Rentas -> Pagos: Cada renta puede tener uno o m\u00e1s pagos. Esquema Relacional: Clientes (1) <--> (M) Rentas Autos (1) <--> (M) Rentas Rentas (1) <--> (M) Pagos","title":"Base de datos"},{"location":"basedatos/#crear-el-modelo-de-base-de-datos","text":"Utilizaremos el siguiente script inicial para crear la base de datos en mysql, el nombre de la base de datos ser\u00e1 rentacardb . DROP DATABASE IF EXISTS rentacardb; CREATE DATABASE rentacardb; USE rentacardb; DROP TABLE IF EXISTS cliente; CREATE TABLE cliente ( id_cliente int NOT NULL AUTO_INCREMENT, direccion varchar(255) DEFAULT NULL, email varchar(255) DEFAULT NULL, nombre varchar(255) DEFAULT NULL, telefono varchar(255) DEFAULT NULL, PRIMARY KEY (id_cliente) ); DROP TABLE IF EXISTS vehiculo; CREATE TABLE vehiculo ( anio int DEFAULT NULL, id_vehiculo int NOT NULL AUTO_INCREMENT, precio double DEFAULT NULL, marca varchar(255) DEFAULT NULL, modelo varchar(255) DEFAULT NULL, estado enum('Disponible','En_Mantenimiento','Rentado') DEFAULT NULL, tipo enum('Camioneta','Compacto','Deportivo','SUV','Sedan') DEFAULT NULL, PRIMARY KEY (id_vehiculo) ); DROP TABLE IF EXISTS reserva; CREATE TABLE reserva ( fecha_fin date DEFAULT NULL, fecha_inicio date DEFAULT NULL, id_cliente int DEFAULT NULL, id_empleado int DEFAULT NULL, id_reserva int NOT NULL, id_vehiculo int DEFAULT NULL, total double DEFAULT NULL, PRIMARY KEY (id_reserva), FOREIGN KEY (id_cliente) REFERENCES cliente (id_cliente), FOREIGN KEY (id_vehiculo) REFERENCES vehiculo (id_vehiculo) ); DROP TABLE IF EXISTS pago; CREATE TABLE pago ( id_pago int NOT NULL AUTO_INCREMENT, id_reserva int DEFAULT NULL, metodo_pago enum('Efectivo','Debito','Credito','Transferencia') DEFAULT NULL, valor double DEFAULT NULL, fecha_pago datetime(6) DEFAULT NULL, PRIMARY KEY (id_pago), KEY id_reserva (id_reserva), CONSTRAINT pago_ibfk_1 FOREIGN KEY (id_reserva) REFERENCES reserva (id_reserva) ); DROP TABLE IF EXISTS usuario; CREATE TABLE usuario ( idusuario int NOT NULL AUTO_INCREMENT, usuario varchar(45) NOT NULL, contrasena varchar(200) NOT NULL, nombre varchar(45) DEFAULT NULL, PRIMARY KEY (idusuario), UNIQUE KEY usuario_UNIQUE (usuario) );","title":"Crear el modelo de base de datos"},{"location":"basedatos/#desplegar-la-base-de-datos-docker","text":"Utilizaremos docker para poder desplegar la base de datos. Docker es un proyecto de c\u00f3digo abierto que automatiza el despliegue de aplicaciones dentro de contenedores de software, proporcionando una capa adicional de abstracci\u00f3n y automatizaci\u00f3n de virtualizaci\u00f3n de aplicaciones en m\u00faltiples sistemas operativos. Docker utiliza caracter\u00edsticas de aislamiento de recursos del kernel Linux, tales como cgroups y espacios de nombres (namespaces) para permitir que 'contenedores' independientes se ejecuten dentro de una sola instancia de Linux, evitando la sobrecarga de iniciar y mantener m\u00e1quinas virtuales. Ac\u00e1 hay un video que explica muy bien el tema de docker, y lo mejor es que es para personas que no tienen conocimiento de esta tecnolog\u00eda: https://www.youtube.com/watch?v=CV_Uf3Dq-EU","title":"Desplegar la base de datos: Docker"},{"location":"basedatos/#instalacion-de-docker","text":"Antes de empezar con Docker, primero necesitamos instalarlo. A continuaci\u00f3n hay unos enlaces que describen la instalaci\u00f3n, dependiendo del Sistema Operativo: Docker en windows Docker en Linux (Ubuntu) Docker en Mac","title":"Instalaci\u00f3n de docker"},{"location":"basedatos/#crear-las-instancias-de-mysql-y-el-cliente-para-mysql","text":"Creamos una instancia de una imagen de mysql con el siguiente comando: docker run --name mysql -e MYSQL_ROOT_PASSWORD=secret -e MYSQL_ROOT_HOST=% -p 127.0.0.1:3307:3306/tcp -d mysql:latest Si todo sale bien, en consola muestra el ID del contenedor: Para conectarnos a la base de datos anterior, necesitamos una aplicaci\u00f3n cliente (Ej. Mysql Workbench, consola de mysql, PhpMyAdmin, etc). PhpMyadmin es un cliente de mysql muy popular, basado en php (utiliza un servidor apache HTTP). Podemos crear un contenedor de docker que tenga, por ejemplo, phpmyadmin: docker run --name phpmyadmin -d --link mysql:db -p 8180:80 phpmyadmin Con esto, ya podemos acceder al servidor de phpmyadmin y luego a la base de datos:","title":"Crear las instancias de mysql y el cliente para mysql"},{"location":"basedatos/#crear-el-contenedor-de-mysql-persistente","text":"Con el comando ejecutado para crear el contenedor de la base de datos, esta por defecto no almacena los datos de forma persistente. Una vez se apague o detenga el contenedor, los datos guardados (tablas creadas, vistas, etc) ser\u00e1n borrados. Debemos agregar al comando algunas opciones para que se pueda guadar la informaci\u00f3n incluso cuando se apague el contenedor. La opci\u00f3n principal para esto es agregar un volumen al contenedor, un espacion en \u00e9l para que pueda guardar informaci\u00f3n que genera la aplicaci\u00f3n contenida. Entonces modificamos el comando para que se ejecute lo siguiente: -- primero se detiene el contenedor docker stop mysql -- ahora el comando para persistir los datos en el contenedor docker run --name mysql -e MYSQL_ROOT_PASSWORD=secret -e MYSQL_ROOT_HOST=% -p 127.0.0.1:3307:3306/tcp -v \"C:/Ejemplos/docker/mysql:/var/lib/mysql\" -d mysql:latest En la carpeta del Host configurada como volumen, nos ha creado algunos archivos:","title":"Crear el contenedor de mysql persistente"},{"location":"basedatos/#utilizar-docker-compose","text":"Docker-Compose es una herramienta que permite manejar aplicaciones Docker. Con Docker-Compose se pueden definir y ejecutar aplicaciones multi-contenedores. En lugar de ejecutar los contenedores uno por uno con la l\u00ednea de comandos de Docker, se puede crear un archivo YAML para definir todos los servicios, redes y vol\u00famenes necesarios para tu aplicaci\u00f3n. En este enlace puede saber m\u00e1s acerca de docker compose: \u00bfQu\u00e9 es Docker Compose? Vamos a crear un archivo docker-compose.yml para definir y ejecutar el servicio de mysql, y el cliente phpmyadmin: services: mysql: image: mysql container_name: mysql ports: - 3307:3306 environment: - MYSQL_ROOT_PASSWORD=root - MYSQL_DATABASE=rentacardb - MYSQL_USER=admin - MYSQL_PASSWORD=admin volumes: - mysql_data:/var/lib/mysql phpmyadmin: image: phpmyadmin environment: - PMA_HOST=mysql depends_on: - mysql container_name: phpmyadmin ports: - 8180:80 volumes: mysql_data:","title":"Utilizar Docker-Compose"},{"location":"basedatos/#crear-los-objetos-en-la-base-de-datos","text":"Ahora con el cliente de phpmyadmin, creamos la base de datos rentacardb y ejecutamos el script de creaci\u00f3n de tablas: En la ventana de phpmyadmin, le damos clic en la pesta\u00f1a SQL y ah\u00ed pegamos y ejecutamos nuestro c\u00f3digo y le damos clic en Continuar: Ahora podemos proceder a crear nuestro backend.","title":"Crear los objetos en la base de datos"},{"location":"intro/","text":"Introducci\u00f3n Con esta guia se pretende orientar en el proceso de crear una aplicaci\u00f3n backend para un proyecto espec\u00edfico: Un negocio de renta de autos. La idea de este proyecto es poder hacer el backend API de un proyecto basado en Arquitectura de tres capas. Para la capa de persistencia se utilizar\u00e1 una base de datos relacional: MySQL . Para el backend Esta ser\u00e1 la primera parte: El backend, utilizaremos el framework Spring Boot . Finalmente se crear\u00e1 un aplicaci\u00f3n Frontend para la interfaz de usuario, con ReactJS . Para cada uno de los componentes de la Arquitectura del sistema, se tratar\u00e1 de crear un contenedor (docker). De esta forma, ser\u00e1 m\u00e1s f\u00e1cil el proceso de despliegue de estos componentes. Organizaci\u00f3n Recomendada del proyecto Hay muchas opciones para poder organizar el sistema. Una de las m\u00e1s sencillas es crear una estructura similar a la siguiente: --proyecto ----proyecto-db # Ac\u00e1 va la configuraci\u00f3n de base de datos o los archivos que necesite de base de datos el proyecto completo . ----proyecto-be # En esta carpeta va nuestro proyecto de Backend ----proyecto-fe # En esta carpeta va el Frontend Herramientas a utilizar Las herramientas a utilizar por cada compomente del proyecto se muestran en la siguiente tabla: Componente Herramienta Descripci\u00f3n Base de datos Mysql Es el motor de base de datos que se utilizara. MySQL Workbench Herramienta que nos servir\u00e1 para gestionar la base de datos (Crear objetos, crear modelos, insertar datos manuales, etc) Backend Spring Framework que se utilizar\u00e1 para el desarrollo del Backend Postman Herramienta para pruebas de API REST Frontend ReactJS Framework para el desarrollo de la interfaz de usuario A nivel general utilizaremos las siguientes herramientas: Herramienta Descripci\u00f3n Visual Studio Code Para codificar los componentes de backend y frontend IntelliJ Igual que la anterior Docker Lo utilizaremos para empaquetar nuestros componentes","title":"Introducci\u00f3n"},{"location":"intro/#introduccion","text":"Con esta guia se pretende orientar en el proceso de crear una aplicaci\u00f3n backend para un proyecto espec\u00edfico: Un negocio de renta de autos. La idea de este proyecto es poder hacer el backend API de un proyecto basado en Arquitectura de tres capas. Para la capa de persistencia se utilizar\u00e1 una base de datos relacional: MySQL . Para el backend Esta ser\u00e1 la primera parte: El backend, utilizaremos el framework Spring Boot . Finalmente se crear\u00e1 un aplicaci\u00f3n Frontend para la interfaz de usuario, con ReactJS . Para cada uno de los componentes de la Arquitectura del sistema, se tratar\u00e1 de crear un contenedor (docker). De esta forma, ser\u00e1 m\u00e1s f\u00e1cil el proceso de despliegue de estos componentes.","title":"Introducci\u00f3n"},{"location":"intro/#organizacion-recomendada-del-proyecto","text":"Hay muchas opciones para poder organizar el sistema. Una de las m\u00e1s sencillas es crear una estructura similar a la siguiente: --proyecto ----proyecto-db # Ac\u00e1 va la configuraci\u00f3n de base de datos o los archivos que necesite de base de datos el proyecto completo . ----proyecto-be # En esta carpeta va nuestro proyecto de Backend ----proyecto-fe # En esta carpeta va el Frontend","title":"Organizaci\u00f3n Recomendada del proyecto"},{"location":"intro/#herramientas-a-utilizar","text":"Las herramientas a utilizar por cada compomente del proyecto se muestran en la siguiente tabla: Componente Herramienta Descripci\u00f3n Base de datos Mysql Es el motor de base de datos que se utilizara. MySQL Workbench Herramienta que nos servir\u00e1 para gestionar la base de datos (Crear objetos, crear modelos, insertar datos manuales, etc) Backend Spring Framework que se utilizar\u00e1 para el desarrollo del Backend Postman Herramienta para pruebas de API REST Frontend ReactJS Framework para el desarrollo de la interfaz de usuario A nivel general utilizaremos las siguientes herramientas: Herramienta Descripci\u00f3n Visual Studio Code Para codificar los componentes de backend y frontend IntelliJ Igual que la anterior Docker Lo utilizaremos para empaquetar nuestros componentes","title":"Herramientas a utilizar"}]}